> **Note**: This README was generated by AI and may not be entirely accurate. Please verify the information and make corrections as needed.

# RV32 Runtime Library Environment

A lightweight runtime environment for RISC-V 32-bit applications with dynamic library function support through a jump table mechanism.

## Overview

This project implements a main RV32 executable and an associated library that can be loaded and executed in QEMU's RISC-V emulation environment. The system uses a shared memory interface and function jump table mechanism to enable dynamic calling between components.

## Project Structure

```
rv32_run_lib/
├── config.mk                  # Common build configuration
├── Makefile                   # Top-level makefile
├── qemu.sh                    # QEMU execution script
├── shared_memory.h            # Memory layout and structure definitions
├── lib/                       # Library component
│   ├── lib_func.c             # Library functions implementation
│   ├── link.ld.S              # Linker script template
│   ├── Makefile               # Library build configuration
│   └── build/                 # Build artifacts
│       └── debug/             # Debug build outputs
└── rv32_main/                 # Main application
    ├── main.c                 # Main entry point
    ├── start.S                # Startup assembly code
    ├── link.ld.S              # Linker script template
    ├── Makefile               # Application build configuration
    └── build/                 # Build artifacts
        └── debug/             # Debug build outputs
```

## Memory Layout

The system uses a predefined memory layout:

- `0x80000000`: Base address for the executable (EXE_BASE)
- `0x80001000`: Base address for the library functions (LIBFUNCS_BASE)
- `0x80002000`: Base address for shared memory region (SHARED_MEM_BASE)

## Components

### Shared Memory Interface

The `shared_memory.h` file defines the memory layout and structures for communication between the main executable and library, including:

- Memory region definitions
- Control area offsets (CMD, PARAM, RESULT, STATUS)
- Status definitions (IDLE, NEW_CMD, EXECUTING, DONE, ERROR)
- Jump table structure for function pointers

### Main Application

The main application (`rv32_main/main.c`) initializes and calls library functions through the jump table mechanism:

1. Locates the jump table at LIBFUNCS_BASE
2. Iterates through available functions in the jump table
3. Calls each function with a provided argument

### Library Component

The library (`lib/lib_func.c`) implements:

- Example functions (func0, func1)
- A jump table structure in a dedicated memory section

## Building and Running

### Prerequisites

- RISC-V GNU Toolchain (riscv64-unknown-elf-*)
- QEMU with RISC-V support

### Build Commands

```bash
# Build everything in debug mode (default)
make

# Build in release mode
make release

# Build just the library
make lib

# Build just the main application
make main

# Clean all build artifacts
make clean
```

### Running

```bash
# Run the application in QEMU
make run

# Debug with GDB
make gdb
```

## Development

To extend the library with new functions:

1. Add new function implementations in `lib/lib_func.c`
2. Update the jump table's `num_functions` and add new function pointers to the `functions` array
3. Rebuild the project